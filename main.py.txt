mport os
import json
import time
from aiogram import Bot, Dispatcher, executor, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

BOT_TOKEN = os.environ["BOT_TOKEN"]

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher(bot)

STATE_FILE = "state.json"
COOLDOWN = 24 * 60 * 60  # 24 Ñ‡Ğ°ÑĞ°


def load_state():
    with open(STATE_FILE, "r", encoding="utf-8") as f:
        return json.load(f)


def save_state(state):
    with open(STATE_FILE, "w", encoding="utf-8") as f:
        json.dump(state, f)


def gifts_keyboard():
    kb = InlineKeyboardMarkup(row_width=3)
    kb.add(
        InlineKeyboardButton("ğŸ 1 ğŸ±", callback_data="gift"),
        InlineKeyboardButton("ğŸ 2 ğŸ®", callback_data="gift"),
        InlineKeyboardButton("ğŸ 3 ğŸ’ª", callback_data="gift"),
        InlineKeyboardButton("ğŸ 4 ğŸŒ¸", callback_data="gift"),
        InlineKeyboardButton("ğŸ 5 ğŸ¬", callback_data="gift"),
        InlineKeyboardButton("ğŸ 6 ğŸ­", callback_data="gift"),
        InlineKeyboardButton("ğŸ 7â¤ï¸", callback_data="gift"),
    )
    return kb


@dp.message_handler(commands=["start"])
async def start(message: types.Message):
    text = (
        "Ğ®Ğ®Ğ®Ğ®Ğ®Ğ›Ğ›Ğ›Ğ›Ğ›Ğ›Ğ›Ğ›Ğ›Ğ¯Ğ¯Ğ¯Ğ¯Ğ¯Ğ¯Ğ¯Ğ¯Ğ¯Ğ¯ ğŸ’›\n\n"
        "Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ±Ğ¾Ñ‚.\n"
        "Ğ­Ñ‚Ğ¾ *Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ¾Ğ¿Ğ°ÑĞ½Ğ°Ñ* ÑˆÑ‚ÑƒĞºĞ°.\n\n"
        "ĞŸĞµÑ€ĞµĞ´ Ñ‚Ğ¾Ğ±Ğ¾Ğ¹ 7 Ğ¿Ğ¾Ğ´Ğ°Ñ€ĞºĞ¾Ğ² ğŸ\n"
        "ĞĞ½Ğ¸ Ğ²ÑĞµ Ñ€Ğ°Ğ·Ğ½Ñ‹Ğµ.\n"
        "ĞĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¿Ğ¾Ğ´Ğ¾Ğ·Ñ€Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ ĞºÑ€ÑƒĞ¿Ğ½Ñ‹Ğµ.\n\n"
        "Ğ’Ñ‹Ğ±Ğ¸Ñ€Ğ°Ğ¹ Ğ»ÑĞ±Ğ¾Ğ¹.\n"
        "ĞĞ¾ Ğ¿Ğ¾Ğ¼Ğ½Ğ¸:\n"
        "ğŸ‘‰ Ğ½Ğ°Ğ·Ğ°Ğ´ Ğ¿ÑƒÑ‚Ğ¸ Ğ½ĞµÑ‚ ğŸ˜"
    )
    await message.answer(text, reply_markup=gifts_keyboard(), parse_mode="Markdown")


@dp.callback_query_handler(lambda c: c.data == "gift")
async def open_gift(call: types.CallbackQuery):
    state = load_state()
    now = time.time()

    if state["opened"]:
        remaining = int((state["opened_at"] + COOLDOWN - now) / 3600)
        await call.answer(
            f"ĞĞ¾Ñƒ Ğ½Ğ¾Ñƒ Ğ½Ğ¾Ñƒ, Ğ¼Ğ¸ÑÑ‚ĞµÑ€ Ñ„Ğ¸Ñˆ ğŸŸ\n"
            f"Ğ•Ñ‰Ñ‘ Ñ€Ğ°Ğ½Ğ¾.\n"
            f"ĞŸĞ¾Ğ´Ğ¾Ğ¶Ğ´Ğ¸ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ½Ğ¾ {remaining} Ñ‡Ğ°ÑĞ¾Ğ² ğŸ˜Œ",
            show_alert=True
        )
        return

    # Ğ˜Ğ»Ğ»ÑĞ·Ğ¸Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°
    await call.message.answer(
        "ĞĞ“Ğ ğŸ˜³\n"
        "Ğ’Ğ¾Ñ‚ Ğ­Ğ¢ĞĞ¢ Ğ¿Ğ¾Ğ´Ğ°Ñ€Ğ¾Ğº?\n\n"
        "Ğ¢Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ğ°?\n"
        "Ğ¯ Ğ±Ñ‹ Ğ½Ğ° Ñ‚Ğ²Ğ¾Ñ‘Ğ¼ Ğ¼ĞµÑÑ‚Ğµ ĞµÑ‰Ñ‘ Ğ¿Ğ¾Ğ´ÑƒĞ¼Ğ°Ğ»...\n\n"
        "Ğ›Ğ°Ğ´Ğ½Ğ¾.\n"
        "ĞŸĞ¾Ğ·Ğ´Ğ½Ğ¾ ğŸ˜"
    )

    time.sleep(1)

    await call.message.answer(
        "ğŸ¶ *Ğ² Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğµ Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ĞµÑ‚ Ğ¸Ğ³Ñ€Ğ°Ñ‚ÑŒ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾ Ğ²ÑÑ€Ğ°Ñ‚Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ Ğ¢Ğ¸Ñ‚Ğ°Ğ½Ğ¸ĞºĞ°* ğŸ¶\n\n"
        "ĞÑƒ Ğ²ÑÑ‘.\n"
        "Ğ¢Ñ‹ ÑÑ‚Ğ¾ ÑĞ´ĞµĞ»Ğ°Ğ»Ğ°."
    )

    time.sleep(1)

    # ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ğ¿Ğ¾Ğ´Ğ°Ñ€ĞºĞ°
    await call.message.answer(
        "ğŸ ĞŸĞĞ”ĞĞ ĞĞš ĞĞ¢ĞšĞ Ğ«Ğ’ĞĞ•Ğ¢Ğ¡Ğ¯â€¦\n\n"
        "Ğ˜ Ğ·Ğ½Ğ°ĞµÑˆÑŒ Ñ‡Ñ‚Ğ¾?\n"
        "ĞšĞ°ĞºĞ¾Ğ¹ Ğ±Ñ‹ Ğ½Ğ¾Ğ¼ĞµÑ€ Ñ‚Ñ‹ Ğ½Ğ¸ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ»Ğ° â€”\n"
        "*Ñ Ğ²ÑÑ‘ Ñ€Ğ°Ğ²Ğ½Ğ¾ Ñ…Ğ¾Ñ‚ĞµĞ» Ğ½Ğ°Ñ‡Ğ°Ñ‚ÑŒ Ğ¸Ğ¼ĞµĞ½Ğ½Ğ¾ Ñ ÑÑ‚Ğ¾Ğ³Ğ¾.*\n\n"
        "ĞŸĞ¾Ñ‚Ğ¾Ğ¼Ñƒ Ñ‡Ñ‚Ğ¾ Ñ‚Ñ‹ â€” Ğ¼Ğ¾Ğ¹ Ğ³Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ´Ğ°Ñ€Ğ¾Ğº â¤ï¸\n\n"
        "Ğ Ñ„Ğ¸Ğ·Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¿Ğ¾Ğ´Ğ°Ñ€Ğ¾Ğº Ñ ÑĞºĞ°Ğ¶Ñƒ Ğ»Ğ¸Ñ‡Ğ½Ğ¾ ğŸ˜‰"
    )

    state["opened"] = True
    state["opened_at"] = now
    save_state(state)

    await call.answer("ĞŸĞ¾Ğ´Ğ°Ñ€Ğ¾Ğº Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ ğŸ’›", show_alert=True)


if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True)
